
Practical 1 : multithreading

*****************************************************prime number****************************************
import threading 
def prime(x,y):
    print("current thread is",threading.current_thread().name)
    p=[]
    for i in range(x,y+1):
        if(i==1):
            continue
        for j in range(2,i):
            if(i%j==0):
                break
        else:
            p.append(i)
    print(f"Prime numbers between {x} and {y} is",p)        
t1=threading.Thread(target=prime,args=(1,10),name="t1")
t2=threading.Thread(target=prime,args=(11,30),name="t2")
print("current thread is",threading.current_thread().name)
t1.start()
t2.start()
t1.join()
t2.join()
print("all threads executed!!")

*********************************************************************************************************

practical 2 : RMI

******interface******
import java.rmi.*;

interface FactInterface extends Remote{
    double getFact(double number) throws RemoteException;
}
 
*******server*******
import java.rmi.*;
import java.rmi.registry.*;
import java.rmi.server.*;

public class FactServer extends UnicastRemoteObject implements FactInterface{
    public FactServer() throws RemoteException{
        System.out.println("The server is initiated");
    }


//cnstr closed

public double getFact(double number){
    double result=1;
    
    for (int i=1; i < number; i++){
        result += result*i;
    }
    return result;
}


    public static void main(String[] args){
        try{
            FactServer server = new FactServer();
            Naming.rebind("//localhost/factcall", server);
        }

        catch(Exception e){
            e.printStackTrace();
        }


    } // main function
}

*************************************************client**************************************************

import java.rmi.*;
import java.rmi.registry.*;
import java.util.Scanner;


public class FactClient{
    public static void main(String[] args){
        try{
            Scanner sc = new Scanner(System.in);

            FactInterface finter = (FactInterface)Naming.lookup("//localhost/factcall");
            
            System.out.println("Enter a number: ");
            double number = sc.nextDouble();

            double res=finter.getFact(number);
            System.out.println("Factorial of "+number+"is "+res);
        }

        catch(Exception e){
            
        }
    }

}//class closed


*********************************************************************************************************

PRAC 3:Write a program to implement Bounded Buffer to solve Producer -
Consumer without Semaphore


from collections.abc import Callable, Iterable, Mapping
from threading import Thread
import time
from typing import Any

class Buffer:
    def __init__(self,size):
        self.size=size
        self.b=[0]*size
        self.into=0 #producer can produce at this pointer
        self.out=0  #consumer consumes from this point
        self.counter=0 #no of iterms present in buffer
    def getvalue(self): #called by consumer to consume an item
        x=self.b[self.out]
        self.out=(self.out+1)%self.size
        self.counter-=1
        return x
    def putvalue(self,value): #called by producer to produce an item
        self.b[self.into]=value
        self.into=(self.into+1)%self.size
        self.counter+=1

class Producer(Thread):
    def __init__(self,buffer1):
        super(Producer,self).__init__()
        self.buffer1=buffer1
    def run(self):
        i=0
        while self.buffer1.counter<self.buffer1.size:
            i+=1
            self.buffer1.putvalue(i)
            print(f"Item {i} is put in buffer \n Current ItemCount :{self.buffer1.counter}")
            time.sleep(5) #simulate delay of work done by producer

class Consumer(Thread):
    def __init__(self,buffer1):
        super(Consumer,self).__init__()
        self.buffer1=buffer1
    def run(self):
        while self.buffer1.counter !=0:
            value=self.buffer1.getvalue()
            print(f" Item {value} is consumed from the buffer \n current ItemCount:{self.buffer1.counter}")
            time.sleep(5) 

buffer1=Buffer(5)
p=Producer(buffer1)
c=Consumer(buffer1)
p.start()
c.start()
c.join()
p.join()

*********************************************************************************************************

PRAC 4: FCFS
def getwaitingtime(n,bt,at,wt):
    st=[0]*n
    for i in range(1,n):
        st[i]=st[i-1]+bt[i-1]
        wt[i]=st[i]-at[i]

def getturnaroundtime(n,bt,wt,tt):
    for i in range(n):
        tt[i]=wt[i]+bt[i]


def display(n,pid,bt,at):
    wt=[0]*n
    tt=[0]*n
    getwaitingtime(n,bt,at,wt)
    getturnaroundtime(n,bt,wt,tt)
    totwt=0
    tottt=0
    print("Process Id\tBT\tAT\tWT\tTAT")
    for i in range(n):
        totwt+=wt[i]
        tottt+=tt[i]
        print(f"\tP{pid[i]}\t{bt[i]}\t{at[i]}\t{wt[i]}\t{tt[i]}")
    avgwt=totwt/n
    avgtat=tottt/n
    print("average waiting time",avgwt) 
    print("average turn around time",avgtat)   


n=int(input("Enter No. of processes")) #total no. of processes
processes=list(map(int,input("enter process Ids seperated by space").split())) 
bursttime=list(map(int,input("enter burst time seperated by space").split())) 
arrivaltime=list(map(int,input("enter arrival time seperated by space").split())) 
display(n,processes,bursttime,arrivaltime)


*********************************************************************************************************

PRAC5 : SJF
finallist = []

def getwt(n, plist):
    runtime = [0] * n
    for i in range(1, n):
        finallist.append(plist[0])
        prevbt = plist[0][2]
        plist.pop(0)
        runtime[i] = runtime[i - 1] + prevbt
        plist = sorted(plist, key=lambda x: (x[2], x[1]))
        plist[0][3] = runtime[i] - plist[0][1]
    finallist.append(plist[0])

def gettat(n, plist):
    for i in range(n):
        plist[i][4] = plist[i][3] + plist[i][2]

def getaveragetime(n, plist):
    getwt(n, plist)
    plist = finallist
    gettat(n, plist)
    print("Process    BT    AT    WT    TAT \n")
    total_wt = 0
    total_tat = 0
    for i in range(n):
        total_wt += plist[i][3]
        total_tat += plist[i][4]
        print(
            f"P{plist[i][0]}\t{plist[i][2]}\t{plist[i][1]}\t{plist[i][3]}\t{plist[i][4]}"
        )
    avgwt = total_wt / n
    avgtat = total_tat / n
    print(f"Average waiting Time: {round(avgwt,2)}")
    print(f"Average turnaroud Time: {avgtat}")

process_list = []
n = int(input("Enter number of processes: "))
for i in range(n):
    process = list(
        map(
            int,
            input(
                f"Enter process no, arrival time and burst time seperated by space: "
            ).split()))
    process.extend([0, 0])
    process_list.append(process)
process_list = sorted(process_list, key=lambda x: (x[1], x[2]))
print(process_list)
getaveragetime(n, process_list)

*********************************************************************************************************

PRAC 6:Write a program to implement Bounded Buffer to solve Producer -
Consumer with Semaphore.

import threading
from threading import Thread
import time
class Buffer():
    def __init__(self,size):
        self.size=size
        self.b=[0]*size
        self.into=0
        self.out=0
        self.empty=threading.Semaphore(size)
        self.full=threading.Semaphore(0)
        self.mutex=threading.Semaphore(1)
    def getvalue(self):
        x=self.b[self.out]
        self.out=(self.out+1)%self.size
        return x
    def putvalue(self,value):
        self.b[self.into]=value
        self.into=(self.into+1)%self.size

class Producer(Thread):
    def __init__(self,buffer1):
        super(Producer,self).__init__()
        self.buffer1=buffer1
    def run(self):
        i=0
        while True:
            i+=1
            self.buffer1.empty.acquire() #wait
            self.buffer1.mutex.acquire() #wait
            
            self.buffer1.putvalue(i) #c.s
            
            self.buffer1.mutex.release() #signal
            self.buffer1.full.release() #signal
            print(f"Item {i} is put into Buffer")
            time.sleep(5)

class Consumer(Thread):
     def __init__(self,buffer1):
        super(Consumer,self).__init__()
        self.buffer1=buffer1
     def run(self):
        while True:
            self.buffer1.full.acquire()
            self.buffer1.mutex.acquire()
            
            value=self.buffer1.getvalue()
            
            self.buffer1.mutex.release()
            self.buffer1.empty.release()
            print(f"\n Item {value} is consumed from Buffer")
            time.sleep(5)
buffer1=Buffer(5)
p=Producer(buffer1)
c=Consumer(buffer1)
p.start()
c.start()
p.join()
c.join()

*********************************************************************************************************
            
PRAC 7:Write a Python program that implements the bankerâ€™s algorithm
#banker's algoo
n=int(input("Enter number of processes"))
m=int(input("Enter Number of resources"))
Allocation=[]
Max=[]
Need=[]
Available=[]
print("Enter the Allocation Matrix elements(one line at a time):")

for i in range(n):
    rowinput=[]
    for j in range(m):
        x=int(input())
        rowinput.append(x)
    Allocation.append(rowinput)

print("Enter the Max Matrix elements(one line at a time):")

for i in range(n):
    rowinput=[]
    for j in range(m):
        x=int(input())
        rowinput.append(x)
    Max.append(rowinput)

for i in range(n):
    rowinput=[]
    for j in range(m):
        x=Max[i][j]-Allocation[i][j]
        rowinput.append(x)
    Need.append(rowinput)         

Resources=[]
for i in range(m):
    x=int(input(f"enter instances for resources {i+1}"))  
    Resources.append(x)
#calculate the available resources
for j in range(m):
    x=0
    for i in range(n):
        x+=Allocation[i][j]
    y=Resources[j]-x
    Available.append(y)
#safety algorithm
work=Available.copy()
finish=[0]*n
Sequence=[]
alldone=False
attempt=0
while alldone==False:
    attempt+=1
    for i in range(n):
        if(finish[i]==0 and Need[i]<=work):
            for k in range(m):
                work[k]+=Allocation[i][k]
            finish[i]=1
            Sequence.append(i)
    for i in range(n):
        if finish[i]==0:
            break
    else:
        alldone=True
    if attempt>2:
        break
if alldone==True:
    print("system is in safe state")
    print(f"safe sequence :{Sequence}")   
else:
    print("System is not safe")     




